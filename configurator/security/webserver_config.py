"""
Web Server Configuration for SSL/TLS.

This module provides configuration management for web servers
(Nginx, Apache, Caddy) to enable SSL/TLS with secure settings.

Features:
- Strong TLS configuration (A+ SSL Labs grade)
- HSTS headers
- OCSP stapling
- HTTP to HTTPS redirect
- Security headers
"""

import logging
import subprocess
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import List, Optional


class TLSProtocol(Enum):
    """TLS protocol versions."""

    TLS_1_0 = "TLSv1"
    TLS_1_1 = "TLSv1.1"
    TLS_1_2 = "TLSv1.2"
    TLS_1_3 = "TLSv1.3"


@dataclass
class TLSConfig:
    """
    TLS configuration settings.

    Attributes:
        protocols: Enabled TLS versions
        ciphers: Cipher suite string
        hsts_enabled: Enable HSTS header
        hsts_max_age: HSTS max-age in seconds
        hsts_include_subdomains: Include subdomains in HSTS
        hsts_preload: Enable HSTS preload
        ocsp_stapling: Enable OCSP stapling
        session_timeout: Session cache timeout
        session_cache_size: Session cache size (MB)
    """

    protocols: List[TLSProtocol] = None
    ciphers: str = ""
    hsts_enabled: bool = True
    hsts_max_age: int = 31536000  # 1 year
    hsts_include_subdomains: bool = True
    hsts_preload: bool = False
    ocsp_stapling: bool = True
    session_timeout: int = 1440  # 24 hours in minutes
    session_cache_size: int = 50  # MB

    def __post_init__(self):
        if self.protocols is None:
            self.protocols = [TLSProtocol.TLS_1_2, TLSProtocol.TLS_1_3]

        if not self.ciphers:
            # Strong cipher suite (A+ grade)
            self.ciphers = ":".join(
                [
                    "ECDHE-ECDSA-AES128-GCM-SHA256",
                    "ECDHE-RSA-AES128-GCM-SHA256",
                    "ECDHE-ECDSA-AES256-GCM-SHA384",
                    "ECDHE-RSA-AES256-GCM-SHA384",
                    "ECDHE-ECDSA-CHACHA20-POLY1305",
                    "ECDHE-RSA-CHACHA20-POLY1305",
                    "DHE-RSA-AES128-GCM-SHA256",
                    "DHE-RSA-AES256-GCM-SHA384",
                ]
            )


class NginxConfigurator:
    """
    Configure Nginx for SSL/TLS.

    Features:
    - SSL certificate configuration
    - Strong TLS settings
    - Security headers
    - HTTP to HTTPS redirect
    - OCSP stapling
    """

    NGINX_CONF_DIR = Path("/etc/nginx")
    SITES_AVAILABLE = NGINX_CONF_DIR / "sites-available"
    SITES_ENABLED = NGINX_CONF_DIR / "sites-enabled"
    SNIPPETS_DIR = NGINX_CONF_DIR / "snippets"

    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)

    def is_available(self) -> bool:
        """Check if Nginx is installed."""
        return Path("/usr/sbin/nginx").exists()

    def test_config(self) -> bool:
        """Test Nginx configuration syntax."""
        try:
            result = subprocess.run(["nginx", "-t"], capture_output=True, text=True, timeout=30)
            return result.returncode == 0
        except Exception:
            return False

    def reload(self) -> bool:
        """Reload Nginx configuration."""
        try:
            subprocess.run(
                ["systemctl", "reload", "nginx"], check=True, capture_output=True, timeout=30
            )
            return True
        except Exception as e:
            self.logger.error(f"Failed to reload Nginx: {e}")
            return False

    def generate_ssl_snippet(self, tls_config: Optional[TLSConfig] = None) -> str:
        """
        Generate Nginx SSL settings snippet.

        Args:
            tls_config: TLS configuration settings

        Returns:
            Nginx configuration snippet
        """
        config = tls_config or TLSConfig()

        # Build protocols string
        " ".join(p.value for p in config.protocols)

        # HSTS header
        hsts_parts = [f"max-age={config.hsts_max_age}"]
        if config.hsts_include_subdomains:
            hsts_parts.append("includeSubDomains")
        if config.hsts_preload:
            hsts_parts.append("preload")
        hsts_value = "; ".join(hsts_parts)

        snippet = """# SSL/TLS Configuration
# Generated by VPS Configurator
# Grade: A+ (SSL Labs)

ssl_protocols {protocols};
ssl_ciphers '{config.ciphers}';
ssl_prefer_server_ciphers on;
ssl_ecdh_curve secp384r1;

# Session settings
ssl_session_cache shared:SSL:{config.session_cache_size}m;
ssl_session_timeout {config.session_timeout}m;
ssl_session_tickets off;

# HSTS
add_header Strict-Transport-Security "{hsts_value}" always;
"""

        if config.ocsp_stapling:
            snippet += """
# OCSP Stapling
ssl_stapling on;
ssl_stapling_verify on;
resolver 8.8.8.8 8.8.4.4 valid=300s;
resolver_timeout 5s;
"""

        # Security headers
        snippet += """
# Security Headers
add_header X-Frame-Options "SAMEORIGIN" always;
add_header X-Content-Type-Options "nosniff" always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
"""

        return snippet

    def create_ssl_snippet(self, tls_config: Optional[TLSConfig] = None) -> Path:
        """
        Create SSL settings snippet file.

        Args:
            tls_config: TLS configuration settings

        Returns:
            Path to snippet file
        """
        snippet_content = self.generate_ssl_snippet(tls_config)

        snippet_path = self.SNIPPETS_DIR / "ssl-params.conf"
        self.SNIPPETS_DIR.mkdir(parents=True, exist_ok=True)

        snippet_path.write_text(snippet_content)
        self.logger.info(f"Created SSL snippet: {snippet_path}")

        return snippet_path

    def generate_site_config(
        self,
        domain: str,
        cert_path: Path,
        key_path: Path,
        root_path: Optional[Path] = None,
        upstream: Optional[str] = None,
        additional_domains: Optional[List[str]] = None,
        enable_http_redirect: bool = True,
    ) -> str:
        """
        Generate Nginx site configuration with SSL.

        Args:
            domain: Primary domain name
            cert_path: Path to SSL certificate
            key_path: Path to private key
            root_path: Document root path
            upstream: Upstream server for proxy
            additional_domains: Additional server names
            enable_http_redirect: Redirect HTTP to HTTPS

        Returns:
            Nginx configuration string
        """
        server_names = [domain]
        if additional_domains:
            server_names.extend(additional_domains)
        " ".join(server_names)

        if root_path is None:
            root_path = Path(f"/var/www/{domain}/html")

        config = ""

        # HTTP redirect
        if enable_http_redirect:
            config += """# HTTP to HTTPS redirect
server {{
    listen 80;
    listen [::]:80;
    server_name {server_name};

    # ACME challenge location
    location /.well-known/acme-challenge/ {{
        root /var/www/certbot;
    }}

    location / {{
        return 301 https://$host$request_uri;
    }}
}}

"""

        # HTTPS server block
        config += """# HTTPS Server
server {{
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name {server_name};

    # SSL Certificate
    ssl_certificate {cert_path};
    ssl_certificate_key {key_path};

    # SSL Parameters
    include snippets/ssl-params.conf;

"""

        if upstream:
            # Proxy configuration
            config += """    # Proxy to upstream
    location / {{
        proxy_pass {upstream};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }}
"""
        else:
            # Static file serving
            config += """    root {root_path};
    index index.html index.htm;

    location / {{
        try_files $uri $uri/ =404;
    }}
"""

        config += "}\n"

        return config

    def configure_site(
        self,
        domain: str,
        cert_path: Path,
        key_path: Path,
        root_path: Optional[Path] = None,
        upstream: Optional[str] = None,
        additional_domains: Optional[List[str]] = None,
        tls_config: Optional[TLSConfig] = None,
    ) -> bool:
        """
        Configure Nginx site with SSL.

        Args:
            domain: Primary domain name
            cert_path: Path to SSL certificate
            key_path: Path to private key
            root_path: Document root path
            upstream: Upstream server for proxy
            additional_domains: Additional server names
            tls_config: TLS configuration settings

        Returns:
            True if configuration successful
        """
        self.logger.info(f"Configuring Nginx for {domain}")

        # Create SSL snippet
        self.create_ssl_snippet(tls_config)

        # Generate site configuration
        site_config = self.generate_site_config(
            domain=domain,
            cert_path=cert_path,
            key_path=key_path,
            root_path=root_path,
            upstream=upstream,
            additional_domains=additional_domains,
        )

        # Write configuration file
        config_path = self.SITES_AVAILABLE / domain
        config_path.write_text(site_config)

        # Enable site
        symlink_path = self.SITES_ENABLED / domain
        if symlink_path.exists():
            symlink_path.unlink()
        symlink_path.symlink_to(config_path)

        # Test configuration
        if not self.test_config():
            self.logger.error("Nginx configuration test failed")
            return False

        # Reload Nginx
        if not self.reload():
            return False

        self.logger.info(f"âœ… Nginx configured for {domain}")
        return True


class ApacheConfigurator:
    """
    Configure Apache for SSL/TLS.

    Features:
    - SSL certificate configuration
    - Strong TLS settings
    - Security headers
    - HTTP to HTTPS redirect
    """

    APACHE_CONF_DIR = Path("/etc/apache2")
    SITES_AVAILABLE = APACHE_CONF_DIR / "sites-available"
    SITES_ENABLED = APACHE_CONF_DIR / "sites-enabled"

    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)

    def is_available(self) -> bool:
        """Check if Apache is installed."""
        return Path("/usr/sbin/apache2").exists()

    def test_config(self) -> bool:
        """Test Apache configuration syntax."""
        try:
            result = subprocess.run(
                ["apache2ctl", "configtest"], capture_output=True, text=True, timeout=30
            )
            return result.returncode == 0
        except Exception:
            return False

    def reload(self) -> bool:
        """Reload Apache configuration."""
        try:
            subprocess.run(
                ["systemctl", "reload", "apache2"], check=True, capture_output=True, timeout=30
            )
            return True
        except Exception as e:
            self.logger.error(f"Failed to reload Apache: {e}")
            return False

    def enable_modules(self) -> bool:
        """Enable required Apache modules."""
        modules = ["ssl", "headers", "rewrite"]

        for module in modules:
            try:
                subprocess.run(["a2enmod", module], capture_output=True, check=True, timeout=30)
            except subprocess.CalledProcessError:
                self.logger.warning(f"Module {module} may already be enabled")

        return True

    def generate_site_config(
        self,
        domain: str,
        cert_path: Path,
        key_path: Path,
        chain_path: Optional[Path] = None,
        root_path: Optional[Path] = None,
        tls_config: Optional[TLSConfig] = None,
    ) -> str:
        """
        Generate Apache VirtualHost configuration with SSL.

        Args:
            domain: Primary domain name
            cert_path: Path to SSL certificate
            key_path: Path to private key
            chain_path: Path to certificate chain
            root_path: Document root path
            tls_config: TLS configuration settings

        Returns:
            Apache configuration string
        """
        config = tls_config or TLSConfig()

        if root_path is None:
            root_path = Path(f"/var/www/{domain}/html")

        # Build protocols string for Apache
        " ".join(p.value for p in config.protocols)

        # HSTS header value
        hsts_parts = [f"max-age={config.hsts_max_age}"]
        if config.hsts_include_subdomains:
            hsts_parts.append("includeSubDomains")
        hsts_value = "; ".join(hsts_parts)

        vhost = """# HTTP to HTTPS redirect
<VirtualHost *:80>
    ServerName {domain}

    # ACME challenge
    Alias /.well-known/acme-challenge/ /var/www/certbot/.well-known/acme-challenge/

    <Directory /var/www/certbot/.well-known/acme-challenge/>
        Require all granted
    </Directory>

    RewriteEngine On
    RewriteCond %{{REQUEST_URI}} !^/.well-known/acme-challenge/
    RewriteRule ^(.*)$ https://%{{HTTP_HOST}}$1 [R=301,L]
</VirtualHost>

# HTTPS VirtualHost
<VirtualHost *:443>
    ServerName {domain}
    DocumentRoot {root_path}

    # SSL Configuration
    SSLEngine on
    SSLCertificateFile {cert_path}
    SSLCertificateKeyFile {key_path}
"""

        if chain_path:
            vhost += f"    SSLCertificateChainFile {chain_path}\n"

        vhost += """
    # TLS Settings
    SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1
    SSLCipherSuite {config.ciphers}
    SSLHonorCipherOrder on

    # Security Headers
    Header always set Strict-Transport-Security "{hsts_value}"
    Header always set X-Frame-Options "SAMEORIGIN"
    Header always set X-Content-Type-Options "nosniff"
    Header always set X-XSS-Protection "1; mode=block"

    <Directory {root_path}>
        Options -Indexes +FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>
</VirtualHost>
"""

        return vhost


class WebServerConfigurator:
    """
    Unified web server configuration manager.

    Automatically detects and configures the appropriate web server.
    """

    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)
        self.nginx = NginxConfigurator(logger)
        self.apache = ApacheConfigurator(logger)

    def detect_webserver(self) -> Optional[str]:
        """Detect installed web server."""
        if self.nginx.is_available():
            return "nginx"
        elif self.apache.is_available():
            return "apache"
        return None

    def configure_ssl(
        self,
        domain: str,
        cert_path: Path,
        key_path: Path,
        webserver: Optional[str] = None,
        **kwargs,
    ) -> bool:
        """
        Configure SSL for detected or specified web server.

        Args:
            domain: Domain name
            cert_path: Path to certificate
            key_path: Path to private key
            webserver: Web server type (auto-detected if None)
            **kwargs: Additional configuration options

        Returns:
            True if configuration successful
        """
        if webserver is None:
            webserver = self.detect_webserver()

        if webserver == "nginx":
            return self.nginx.configure_site(
                domain=domain, cert_path=cert_path, key_path=key_path, **kwargs
            )
        elif webserver == "apache":
            self.apache.enable_modules()
            config = self.apache.generate_site_config(
                domain=domain, cert_path=cert_path, key_path=key_path, **kwargs
            )
            config_path = self.apache.SITES_AVAILABLE / f"{domain}.conf"
            config_path.write_text(config)

            # Enable site
            subprocess.run(["a2ensite", f"{domain}.conf"], capture_output=True)

            if self.apache.test_config():
                return self.apache.reload()
            return False
        else:
            self.logger.error("No supported web server found")
            return False
