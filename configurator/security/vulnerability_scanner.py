import json
import logging
import shutil
import subprocess
import time
import uuid
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional

# --- Data Models ---


class VulnerabilitySeverity(Enum):
    """CVE severity levels (CVSS-based)"""

    CRITICAL = "critical"  # CVSS 9.0-10.0
    HIGH = "high"  # CVSS 7.0-8.9
    MEDIUM = "medium"  # CVSS 4.0-6.9
    LOW = "low"  # CVSS 0.1-3.9
    UNKNOWN = "unknown"  # No CVSS score


@dataclass
class Vulnerability:
    """
    Represents a detected vulnerability (CVE).
    """

    cve_id: str  # CVE identifier
    package_name: str  # Affected package
    installed_version: str  # Currently installed version
    fixed_version: Optional[str]  # Version with fix (if available)
    severity: VulnerabilitySeverity  # Severity level
    cvss_score: Optional[float]  # CVSS score (0-10)
    description: str  # Vulnerability description
    published_date: Optional[datetime] = None
    exploit_available: bool = False  # Is public exploit available?
    references: List[str] = field(default_factory=list)  # URLs to advisories
    target_type: str = "package"  # package, container, os

    def to_dict(self) -> Dict:
        """Serialize to dictionary"""
        return {
            "cve_id": self.cve_id,
            "package_name": self.package_name,
            "installed_version": self.installed_version,
            "fixed_version": self.fixed_version,
            "severity": self.severity.value,
            "cvss_score": self.cvss_score,
            "description": self.description,
            "published_date": self.published_date.isoformat() if self.published_date else None,
            "exploit_available": self.exploit_available,
            "references": self.references,
            "target_type": self.target_type,
        }


@dataclass
class ScanResult:
    """Result of vulnerability scan"""

    scan_id: str
    scan_date: datetime
    scanner_name: str
    scanner_version: str
    target: str  # What was scanned
    vulnerabilities: List[Vulnerability]
    scan_duration_seconds: float

    def get_summary(self) -> Dict:
        """Get summary statistics"""
        by_severity = {
            VulnerabilitySeverity.CRITICAL: 0,
            VulnerabilitySeverity.HIGH: 0,
            VulnerabilitySeverity.MEDIUM: 0,
            VulnerabilitySeverity.LOW: 0,
            VulnerabilitySeverity.UNKNOWN: 0,
        }

        for vuln in self.vulnerabilities:
            by_severity[vuln.severity] += 1

        # Count vulnerabilities with fixes available
        fixable = len([v for v in self.vulnerabilities if v.fixed_version])

        # Count by target type
        by_type = {}
        for vuln in self.vulnerabilities:
            by_type[vuln.target_type] = by_type.get(vuln.target_type, 0) + 1

        return {
            "total": len(self.vulnerabilities),
            "by_severity": {k.value: v for k, v in by_severity.items()},
            "fixable": fixable,
            "by_type": by_type,
        }


class VulnerabilityScanner(ABC):
    """
    Abstract base class for vulnerability scanners.
    """

    def __init__(self, logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)

    @abstractmethod
    def is_available(self) -> bool:
        """Check if scanner is installed and available"""

    @abstractmethod
    def scan_system(self) -> ScanResult:
        """Scan system packages for vulnerabilities"""

    @abstractmethod
    def scan_docker_image(self, image: str) -> ScanResult:
        """Scan Docker image for vulnerabilities"""

    @abstractmethod
    def get_version(self) -> str:
        """Get scanner version"""


# --- Trivy Implementation ---


class TrivyScanner(VulnerabilityScanner):
    """
    Trivy vulnerability scanner integration.
    """

    SCANNER_NAME = "Trivy"

    def __init__(self, logger: Optional[logging.Logger] = None):
        super().__init__(logger)
        # We don't call _check_installation in init to avoid log spam on import or simple check,
        # but let's stick closer to the pattern:
        # self._check_installation()

    def is_available(self) -> bool:
        """Check if Trivy is installed"""
        return shutil.which("trivy") is not None

    def get_version(self) -> str:
        """Get Trivy version"""
        try:
            result = subprocess.run(
                ["trivy", "--version"], capture_output=True, text=True, check=True
            )
            # Parse version from output: "Version: 0.48.0"
            for line in result.stdout.split("\n"):
                if "Version:" in line:
                    return line.split(":")[1].strip()
            return "unknown"
        except Exception as e:
            self.logger.error(f"Failed to get Trivy version: {e}")
            return "unknown"

    def scan_system(self) -> ScanResult:
        """
        Scan system packages using Trivy.
        """
        self.logger.info("Starting Trivy system scan...")

        if not self.is_available():
            raise RuntimeError("Trivy is not installed")

        scan_start = time.time()

        # Run Trivy in filesystem mode
        try:
            result = subprocess.run(
                [
                    "trivy",
                    "rootfs",
                    "/",
                    "--format",
                    "json",
                    "--severity",
                    "UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL",
                    "--no-progress",
                    "--scanners",
                    "vuln",  # Explicitly only vuln scanning, skip misconfig/secret for now as requested
                ],
                capture_output=True,
                text=True,
                check=True,
                timeout=600,  # 10 minute timeout
            )

            scan_duration = time.time() - scan_start

            # Parse JSON output
            trivy_data = json.loads(result.stdout)

            # Convert to our Vulnerability format
            vulnerabilities = self._parse_trivy_output(trivy_data)

            self.logger.info(
                f"Trivy scan complete: {len(vulnerabilities)} vulnerabilities found "
                f"in {scan_duration:.2f}s"
            )

            return ScanResult(
                scan_id=str(uuid.uuid4()),
                scan_date=datetime.now(),
                scanner_name=self.SCANNER_NAME,
                scanner_version=self.get_version(),
                target="system",
                vulnerabilities=vulnerabilities,
                scan_duration_seconds=scan_duration,
            )

        except subprocess.TimeoutExpired:
            self.logger.error("Trivy scan timed out after 10 minutes")
            raise
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Trivy scan failed: {e.stderr}")
            raise
        except json.JSONDecodeError as e:
            self.logger.error(f"Failed to parse Trivy output: {e}")
            raise

    def scan_docker_image(self, image: str) -> ScanResult:
        """
        Scan Docker image using Trivy.
        """
        self.logger.info(f"Scanning Docker image: {image}")

        if not self.is_available():
            raise RuntimeError("Trivy is not installed")

        scan_start = time.time()

        try:
            result = subprocess.run(
                [
                    "trivy",
                    "image",
                    image,
                    "--format",
                    "json",
                    "--severity",
                    "UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL",
                    "--no-progress",
                    "--scanners",
                    "vuln",
                ],
                capture_output=True,
                text=True,
                check=True,
                timeout=600,
            )

            scan_duration = time.time() - scan_start

            trivy_data = json.loads(result.stdout)
            vulnerabilities = self._parse_trivy_output(trivy_data, target_type="container")

            self.logger.info(f"Docker image scan complete: {len(vulnerabilities)} vulnerabilities")

            return ScanResult(
                scan_id=str(uuid.uuid4()),
                scan_date=datetime.now(),
                scanner_name=self.SCANNER_NAME,
                scanner_version=self.get_version(),
                target=f"docker:{image}",
                vulnerabilities=vulnerabilities,
                scan_duration_seconds=scan_duration,
            )

        except subprocess.CalledProcessError as e:
            self.logger.error(f"Docker image scan failed: {e.stderr}")
            raise

    def _parse_trivy_output(
        self, trivy_data: Dict, target_type: str = "package"
    ) -> List[Vulnerability]:
        """
        Parse Trivy JSON output into Vulnerability objects.
        """
        vulnerabilities = []

        results = trivy_data.get("Results", [])

        for result in results:
            vulns = result.get("Vulnerabilities", [])

            for vuln_data in vulns:
                # Parse severity
                severity_str = vuln_data.get("Severity", "UNKNOWN").lower()
                severity_map = {
                    "critical": VulnerabilitySeverity.CRITICAL,
                    "high": VulnerabilitySeverity.HIGH,
                    "medium": VulnerabilitySeverity.MEDIUM,
                    "low": VulnerabilitySeverity.LOW,
                    "unknown": VulnerabilitySeverity.UNKNOWN,
                }
                severity = severity_map.get(severity_str, VulnerabilitySeverity.UNKNOWN)

                # Parse CVSS score
                cvss_score = None
                cvss_data = vuln_data.get("CVSS", {})
                if cvss_data:
                    # Try to get score from any CVSS version
                    for version in ["nvd", "redhat", "vendor"]:
                        if version in cvss_data:
                            score_data = cvss_data[version]
                            if isinstance(score_data, dict):
                                cvss_score = score_data.get("V3Score") or score_data.get("V2Score")
                            break

                # Parse dates
                published_date = None
                if vuln_data.get("PublishedDate"):
                    try:
                        published_date = datetime.fromisoformat(
                            vuln_data["PublishedDate"].replace("Z", "+00:00")
                        )
                    except Exception:
                        pass

                vulnerability = Vulnerability(
                    cve_id=vuln_data.get("VulnerabilityID", "UNKNOWN"),
                    package_name=vuln_data.get("PkgName", "unknown"),
                    installed_version=vuln_data.get("InstalledVersion", "unknown"),
                    fixed_version=vuln_data.get("FixedVersion"),
                    severity=severity,
                    cvss_score=cvss_score,
                    description=vuln_data.get("Description", "No description available"),
                    published_date=published_date,
                    exploit_available=False,
                    references=vuln_data.get("References", []),
                    target_type=target_type,
                )

                vulnerabilities.append(vulnerability)

        return vulnerabilities


# --- Grype Implementation ---


class GrypeScanner(VulnerabilityScanner):
    """
    Grype vulnerability scanner integration.
    """

    SCANNER_NAME = "Grype"

    def is_available(self) -> bool:
        """Check if Grype is installed"""
        return shutil.which("grype") is not None

    def get_version(self) -> str:
        """Get Grype version"""
        try:
            result = subprocess.run(
                ["grype", "version"], capture_output=True, text=True, check=True
            )
            # Parse version from output
            for line in result.stdout.split("\n"):
                if "Version:" in line:
                    return line.split(":")[1].strip()
            return "unknown"
        except Exception:
            return "unknown"

    def scan_system(self) -> ScanResult:
        """Scan system with Grype"""
        self.logger.info("Starting Grype system scan...")

        if not self.is_available():
            raise RuntimeError("Grype is not installed")

        scan_start = time.time()

        try:
            result = subprocess.run(
                ["grype", "dir:/", "--output", "json", "--scope", "all-layers"],
                capture_output=True,
                text=True,
                check=True,
                timeout=600,
            )

            scan_duration = time.time() - scan_start

            grype_data = json.loads(result.stdout)
            vulnerabilities = self._parse_grype_output(grype_data)

            return ScanResult(
                scan_id=str(uuid.uuid4()),
                scan_date=datetime.now(),
                scanner_name=self.SCANNER_NAME,
                scanner_version=self.get_version(),
                target="system",
                vulnerabilities=vulnerabilities,
                scan_duration_seconds=scan_duration,
            )

        except subprocess.CalledProcessError as e:
            self.logger.error(f"Grype scan failed: {e.stderr}")
            raise

    def scan_docker_image(self, image: str) -> ScanResult:
        """Scan Docker image with Grype"""
        self.logger.info(f"Scanning Docker image with Grype: {image}")

        scan_start = time.time()

        try:
            result = subprocess.run(
                ["grype", image, "--output", "json"],
                capture_output=True,
                text=True,
                check=True,
                timeout=600,
            )

            scan_duration = time.time() - scan_start
            grype_data = json.loads(result.stdout)
            vulnerabilities = self._parse_grype_output(grype_data, target_type="container")

            return ScanResult(
                scan_id=str(uuid.uuid4()),
                scan_date=datetime.now(),
                scanner_name=self.SCANNER_NAME,
                scanner_version=self.get_version(),
                target=f"docker:{image}",
                vulnerabilities=vulnerabilities,
                scan_duration_seconds=scan_duration,
            )

        except subprocess.CalledProcessError as e:
            self.logger.error(f"Grype Docker scan failed: {e.stderr}")
            raise

    def _parse_grype_output(
        self, grype_data: Dict, target_type: str = "package"
    ) -> List[Vulnerability]:
        """Parse Grype JSON output"""
        vulnerabilities = []

        matches = grype_data.get("matches", [])

        for match in matches:
            vuln_data = match.get("vulnerability", {})
            artifact = match.get("artifact", {})

            # Parse severity
            severity_str = vuln_data.get("severity", "Unknown").lower()
            severity_map = {
                "critical": VulnerabilitySeverity.CRITICAL,
                "high": VulnerabilitySeverity.HIGH,
                "medium": VulnerabilitySeverity.MEDIUM,
                "low": VulnerabilitySeverity.LOW,
                "negligible": VulnerabilitySeverity.LOW,
                "unknown": VulnerabilitySeverity.UNKNOWN,
            }
            severity = severity_map.get(severity_str, VulnerabilitySeverity.UNKNOWN)

            # Get fix version
            fix_version = None
            fix_data = vuln_data.get("fix", {})
            if fix_data:
                fix_version = fix_data.get("versions", [None])[0]

            vulnerability = Vulnerability(
                cve_id=vuln_data.get("id", "UNKNOWN"),
                package_name=artifact.get("name", "unknown"),
                installed_version=artifact.get("version", "unknown"),
                fixed_version=fix_version,
                severity=severity,
                cvss_score=None,  # Grype doesn't always provide CVSS in basic output
                description=vuln_data.get("description", "No description"),
                references=vuln_data.get("urls", []),
                target_type=target_type,
            )

            vulnerabilities.append(vulnerability)

        return vulnerabilities


# --- Vulnerability Manager ---


class VulnerabilityManager:
    """
    High-level vulnerability management.
    """

    def __init__(self, preferred_scanner: str = "trivy", logger: Optional[logging.Logger] = None):
        self.logger = logger or logging.getLogger(__name__)
        self.preferred_scanner = preferred_scanner

        # Initialize scanners
        self.scanners = {
            "trivy": TrivyScanner(logger),
            "grype": GrypeScanner(logger),
        }

        # Detect available scanners
        self.available_scanners = [
            name for name, scanner in self.scanners.items() if scanner.is_available()
        ]

        if not self.available_scanners:
            self.logger.warning("No vulnerability scanners available! Install Trivy or Grype.")

    def get_scanner(self) -> VulnerabilityScanner:
        """Get preferred scanner (or fallback)"""
        if self.preferred_scanner in self.available_scanners:
            return self.scanners[self.preferred_scanner]
        elif self.available_scanners:
            # Fallback to first available
            fallback = self.available_scanners[0]
            self.logger.info(f"Using fallback scanner: {fallback}")
            return self.scanners[fallback]
        else:
            raise RuntimeError("No vulnerability scanner available")

    def scan_system(self) -> ScanResult:
        """Scan system for vulnerabilities"""
        scanner = self.get_scanner()
        return scanner.scan_system()

    def scan_docker_images(self) -> List[ScanResult]:
        """Scan all Docker images on system"""
        scanner = self.get_scanner()

        # Get list of Docker images
        try:
            result = subprocess.run(
                ["docker", "images", "--format", "{{.Repository}}:{{.Tag}}"],
                capture_output=True,
                text=True,
                check=True,
            )

            images = result.stdout.strip().split("\n")
            images = [img for img in images if img and "<none>" not in img]

            self.logger.info(f"Found {len(images)} Docker images to scan")

            scan_results = []
            for image in images:
                try:
                    self.logger.info(f"Scanning image: {image}")
                    result = scanner.scan_docker_image(image)
                    scan_results.append(result)
                except Exception as e:
                    self.logger.error(f"Failed to scan {image}: {e}")

            return scan_results

        except subprocess.CalledProcessError:
            self.logger.info("Docker not available or no images found")
            return []
        except FileNotFoundError:
            self.logger.info("Docker command not found")
            return []

    def get_critical_vulnerabilities(self, scan_result: ScanResult) -> List[Vulnerability]:
        """Get critical and high severity vulnerabilities"""
        return [
            v
            for v in scan_result.vulnerabilities
            if v.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]
        ]

    def auto_remediate(
        self,
        scan_result: ScanResult,
        severity_threshold: VulnerabilitySeverity = VulnerabilitySeverity.HIGH,
    ) -> Dict:
        """
        Auto-remediate vulnerabilities by upgrading packages.
        """
        self.logger.info("Starting auto-remediation...")

        # Filter vulnerabilities by severity
        to_remediate = [
            v
            for v in scan_result.vulnerabilities
            if v.fixed_version
            and self._meets_threshold(v.severity, severity_threshold)
            and v.target_type == "package"
        ]

        if not to_remediate:
            self.logger.info("No remediable vulnerabilities found")
            return {"upgraded": 0, "failed": 0, "skipped": 0}

        self.logger.info(f"Attempting to remediate {len(to_remediate)} vulnerabilities")

        # Group by package (deduplicate)
        packages_to_upgrade = {}
        for vuln in to_remediate:
            if vuln.package_name not in packages_to_upgrade:
                packages_to_upgrade[vuln.package_name] = vuln

        upgraded = 0
        failed = 0

        for package_name, vuln in packages_to_upgrade.items():
            try:
                self.logger.info(f"Upgrading {package_name} to fix {vuln.cve_id}")

                # Use apt-get for system packages
                # This assumes Debian environment as per project context
                result = subprocess.run(
                    ["apt-get", "install", "--only-upgrade", "-y", package_name],
                    capture_output=True,
                    text=True,
                    check=True,
                )

                upgraded += 1
                self.logger.info(f"  ✅ Upgraded {package_name}")

            except subprocess.CalledProcessError as e:
                failed += 1
                self.logger.error(f"  ❌ Failed to upgrade {package_name}: {e.stderr}")

        return {
            "upgraded": upgraded,
            "failed": failed,
            "total": len(packages_to_upgrade),
        }

    def _meets_threshold(
        self, severity: VulnerabilitySeverity, threshold: VulnerabilitySeverity
    ) -> bool:
        """Check if severity meets threshold"""
        severity_order = [
            VulnerabilitySeverity.LOW,
            VulnerabilitySeverity.MEDIUM,
            VulnerabilitySeverity.HIGH,
            VulnerabilitySeverity.CRITICAL,
        ]

        try:
            return severity_order.index(severity) >= severity_order.index(threshold)
        except ValueError:
            return False
